<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //JSON
    var obj = {
        a: 'Hello',
        b: 'World'
    };
    var json = '{"a": "Hello", "b": "World"}';//json,

    var str = JSON.stringify(obj);// obj==>string
    console.log(typeof str);

    var obj3 = JSON.parse(json);//  string==>object
    console.log(obj3);


    var userinfo = {
        username:"zhangsan",
        age:"18",
        school:"nongda"
    };
    var uStr = JSON.stringify(userinfo);
    console.log(uStr);

    //json2.js  解决兼容性问题

    var a = 5;
    var b = a;
    a = 6;
    console.log(b);//b=5; 基本数据类型存在栈里占用不同的空间 引用数据类型存在堆里


    var obj1= {
        name:"zhangsan",
        age:"18",
        dad:{
            name:"zhanger",
            age:"45"
        }
    };
//    var obj2 = obj1;     //浅拷贝：指向的还是同一个空间，并不是两个独立的对象。
//    obj1.name = "lisi";
//    console.log(obj2);//对象存在堆里面 obj1和obj2指向同一内存空间。


    //深拷贝或者深克隆，两个完全独立的对象

//    var obj4 = {};//有开辟了一个新的内存空间，与obj1相互之间不影响。
//    obj4.name = obj1.name;
//    obj4.age = obj.age;
//
//    obj1.name = "lisi";
//    console.log(obj4);//没有改变

    var obj5 = clone(obj1);
    //obj1.name = "lisi";
    obj1.dad.name = "zhangda";

    console.log(obj1);
    console.log(obj5);



    function clone(obj) {
        var newObj = {};
        for(var p in obj){//遍历对象的属性用for in  循环谁就in谁
            if(typeof(obj[p]) == "object"){//typeof返回的值是个字符串
                newObj[p] = clone(obj[p]);  // 递归
            }else{
                newObj[p] = obj[p];
            }
        }
        return newObj;
    }


     var obj1Str = JSON.stringify(obj1);
     var obj6 = JSON.parse(obj1Str);
     obj1.dad.name = "zhangXX";
     console.log(obj6);


     eval("while(1){alert(123)}");//将比json来讲不安全。


</script>
</body>
</html>
